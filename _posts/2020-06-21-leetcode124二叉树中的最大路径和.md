---
layout:     post
title:      leetcode124二叉树中的最大路径和
subtitle:   leetcode 124 Binary Tree Maximum Path Sum
author:     BY
header-img: img/post-bg-universe.jpg
catalog: true
tags:
    - Blog
---


## 前言

持续更新了

## 正文

### 问题来源

本问题来自leetcode上的124题。  

### 问题描述

给定一个非空二叉树，返回其最大路径和。  
本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。  

#### 示例 1:
```
输入: [1,2,3]

       1
      / \
     2   3

输出: 6
```

#### 示例 2:
```
输入: [-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

输出: 42
```

#### 分析：
朴素的思想：（回溯法）  
```
func isMatch(s string, p string) bool {
    return subMatch(s, p, 0, 0)
}

func subMatch(s, p string, si, pi int) bool {
	// 结束判断
    if si >= len(s) {
        if pi >= len(p) {
            return true
        }
        if pi + 1 < len(p) && p[pi+1] == '*' { //形如s:a p:ab*
            return subMatch(s,p,si, pi+2)
        }
        return false
    } else if pi >= len(p) {
        return false
    }
    if pi + 1 < len(p) && p[pi+1] == '*' {
        if p[pi] == '.' {
            if subMatch(s,p,si, pi+2) { //.*一个字符都不消费
                return true
            }
            for i := si; i < len(s); i++ { //可以尝试匹配到最后
                if subMatch(s,p,i+1, pi+2) {
                    return true
                }
            }
            return false
        } else {
            if subMatch(s,p,si, pi+2) { // x*一个字符都不消费(x为si所指字符)
                return true
            }
            for i := si; i < len(s) && s[i] == p[pi]; i++ { //匹配到不相等为止
                if subMatch(s,p,i+1, pi+2) {
                    return true
                }
            }
            return false
        }
    }
    if p[pi] == '.' || p[pi] == s[si] {
        return subMatch(s, p, si+1, pi+1)
    }
    return false // p[pi] != '.' && p[pi] != s[si]
}
```

#### 总结：
勤思考。  

## 结语
不管怎么样好好加油。  
